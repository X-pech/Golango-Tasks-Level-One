# WB Tech: level # 1 (Golang)

## Как делать задания

В заданиях никаких устных решений — только код. Одно решение — один файл с хорошо откомментированным кодом. Каждое решение или невозможность решения надо объяснить.

Разрешается и приветствуется использование любых справочных ресурсов, привлечение сторонних экспертов и т.д. и т.п.

Основной критерий оценки — четкое понимание «как это работает». Некоторые задачи можно решить несколькими способами, в этом случае требуется привести максимально возможное количество вариантов.

Можно задавать вопросы, как по условию задач, так и об их решении. Идеальный вариант — продемонстрировать свои решения и получить максимальный фидбэк от опытных разработчиков Wildberries.

## Задания

1. - [x] Дана структура Human (с произвольным набором полей и методов). Реализовать встраивание методов в структуре Action от родительской структуры Human (аналог наследования).

1. - [x] Написать программу, которая конкурентно рассчитает значение квадратов чисел взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout.

2. - [x] Дана последовательность чисел: 2,4,6,8,10. Найти сумму их квадратов(22+32+42….) с использованием конкурентных вычислений.

3. - [x] Реализовать постоянную запись данных в канал (главный поток). Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout. Необходима возможность выбора количества воркеров при старте. Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.


4. - [x] Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала — читать. По истечению N секунд программа должна завершаться.

5. - [x] Реализовать все возможные способы остановки выполнения горутины.

6. - [x] Реализовать конкурентную запись данных в map.

7. - [x] Дана переменная int64. Разработать программу которая устанавливает i-й бит в 1 или 0.

8. - [x] Разработать конвейер чисел. Даны два канала: в первый пишутся числа (x) из массива, во второй — результат операции x\*2, после чего данные из второго канала должны выводиться в stdout.

9. - [x] Дана последовательность температурных колебаний: -25.4, -27.0 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить данные значения в группы с шагом в 10 градусов. Последовательность в подмножноствах не важна. Пример: `-20:{-25.0, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20: {24.5}` etc.

1. - [x] Реализовать пересечение двух неупорядоченных множеств.

2. - [x] Имеется последовательность строк - (cat, cat, dog, cat, tree) создать для нее собственное множество.

3. - [x] Поменять местами два числа без создания временной переменной.

4. - [x] Разработать программу, которая в рантайме способна определить тип переменной: int, string, bool, channel из переменной типа interface{}.

5. - [x] К каким негативным последствиям может привести данный фрагмент кода, и как это исправить? Приведите корректный пример реализации.


    ```go
    var justString string

    func someFunc() {

    v := createHugeString(1 << 10)

    justString = v[:100]

    }

    func main() {

    someFunc()

    }
    ```

1. - [x] Реализовать быструю сортировку массива (quicksort) встроенными методами языка.

2. - [x] Реализовать бинарный поиск встроенными методами языка.

3. - [x] Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде. По завершению программа должна выводить итоговое значение счетчика.

4. - [x] Разработать программу, которая переворачивает подаваемую на ход строку (например: «главрыба — абырвалг»). Символы могут быть unicode.

5. - [x] Разработать программу, которая переворачивает слова в строке.
 Пример: «snow dog sun — sun dog snow».

6. - [x] Реализовать паттерн «адаптер» на любом примере.

7. - [x] Разработать программу, которая перемножает, делит, складывает, вычитает две числовых переменных a,b, значение которых \> 2^20.

8. - [x] Удалить i-ый элемент из слайса.

9. - [x] Разработать программу нахождения расстояния между двумя точками, которые представлены в виде структуры Point с инкапсулированными параметрами x,y и конструктором.

10. - [x] Реализовать собственную функцию sleep.

11. - [x] Разработать программу, которая проверяет, что все символы в строке уникальные (true — если уникальные, false etc). Функция проверки должна быть регистронезависимой.

    Например:
    abcd — true

    abCdefAaf — false
    aabcd — false

## Устные вопросы

1. - [x] Какой самый эффективный способ конкатенации строк?

    `strings.Builder` - потому что он не пересоздаёт строку каждый раз при добавлении в неё, а работает как срез (минимизирует реаллокацию памяти засчёт разделения вместимости/размера)

2. - [x] Что такое интерфейсы, как они применяются в Go?

    Интерфейсы - это описание способа взаимодействия с объектами, если быть более конкретным - описание сигнатур методов, которые должны быть реализованы объектом чтобы он мог "реализовать" этот интерфейс. Они применяются чтобы задать общие способы взаимодействия с разными объектами, например мы можем ссылаться на объект как на интерфейс тем самым абстрагировать какой-то код до выделенных интерфейсом методов. В Го они так и применяются, единственное отличие от конвенциональных ООП-языков, что в Го объекты не объявляют то что они реализуют интерфейс, им достаточно просто реализовать аналогичный набор методов и если он присутствует у структуры, то Го позволит обращаться к этому объекту через этот интерфейс.

3. - [x] Чем отличаются RWMutex от Mutex?

    Mutex реализует обычный мьютекс, который можно заблокировать/разблокировать. RWMutex реализует мьютекс для чтения-записи, который позволяет блокировать объект для записи (одной горутиной) или блокировать объект для чтения (при этом нельзя заблокировать его для записи, но можно заблокировать его для чтения - то есть можно конкуретно/параллельно читать его, но не писать)
    
    Где-то тут я решил что я перепишу задачу про конкуретный `map` (✔ сделано)

4. - [x] Чем отличаются буферизированные и не буферизированные каналы?

        Обычные и буферизированные каналы в сущности одно и то же разница заключается во вместимости канала по достижению которой канал перестаёт принимать новые сообщения, то есть блокируется. У обычных каналов он равен 1, а у буферизированных - указанному *n*. Если нам нужно принимать сообщения от многих горутин, то лучше сделать буферизированный канал чтобы они не ждали друг-друга.

5. - [x] Какой размер у структуры struct{}{}?
    
    0 байт (проверил `unsafe.Sizeof()`)

6. - [x] Есть ли в Go перегрузка методов или операторов?

    Нет, это не реализовали во славу простоты+скорости компиляции которая была приоритетом при разработке Го 

7. - [x] В какой последовательности будут выведены элементы map[int]int?

    _Пример:_

    ```golang
    m[0]=1

    m[1]=124

    m[2]=281
    ```

    В порядке возрастания их хэшей. `map` в Го - это хэш-таблица и не гарантирует никакой порядок ключей, как основанный на их значениях так и на порядке добавления 

1. - [x] В чем разница make и new?

    new выделяет память под структуру и инициализирует её значением по-умолчанию, в то время как make используется только для инициализации `map`, `slice` и `chan` - то есть для трёх встроенных "коллекций" в го.

2. - [x] Сколько существует способов задать переменную типа slice или map?

    1. Срезы
        1. `var arr []int` // nil-срез, len=0, cap=0, append по-сути создаёт срез
        2. `var arr = []int{2, 2, 2}` инициализированный срез
        3. `arr := make([]int, size, cap)` - "конструктор" среза
    2. Мапы
        1. Литерал
            ```
            var dict = map[int]int {
                0: val1,
                3: val2,
            }
            ``` 
        2. `var dict := make(map[int]int, cap)` - "конструктор" мапы
        3. Объявление мапы не инициализирует её и в отличие от срезов обращение по ключу вызывает `panic` из-за того что мапа `nil`

    Итого: 5



3. - [x] Что выведет данная программа и почему?

    ```golang
    func update(p *int) {

    b := 2

    p = &b

    }

    func main() {

    var (

    a = 1

    p = &a

    )

    fmt.Println(*p)

    update(p)

    fmt.Println(*p)

    }
    ```

    Программа выводит 1. Это происходит потому что `p` - это `*int`. Указатели де-факто - это просто числа и при передаче в функцию мы передаёт указатель по-сути просто напросто как число. Присваивая ему значение другого указателя, мы меняем указатель в функции, но не снаружи - указатели ведь это значимый тип. Говоря метафорами, которые я обычно объясняю студентам этот момент, передав в функцию указатель мы всё равно его скопировали, просто копирование произошло не магазина (значения по указателю) а самого указателя (визитки). Если мы на визитке зачернкём адрес и напишем другой - старая визитка от этого не поменяется. Вот если бы мы передали `**int` - было бы другое дело.

1. - [x] Что выведет данная программа и почему?


    ```go
    func main() {

    wg := sync.WaitGroup{}

    for i := 0; i < 5; i++ {

    wg.Add(1)

    go func (wg sync.WaitGroup, i int) {

    fmt.Println(i)

    wg.Done()

    }(wg, i)

    }

    wg.Wait()

    fmt.Println( "exit" )

    }
    ```

    числа 1..5

    `exit` она точно не выведет потому что мы передаём WaitGroup по значению а WaitGroup - это такой конкурентный счётчик, по-сути. Если мы передаём его по значению он копируется и теперь у нас два разных счёчтика. Тот которого мы ждйм в `wg.Wait()` до нуля не опустится

1. - [x] Что выведет данная программа и почему?

    ```go

    func main() {

    n := 0

    if _ true _ {

    n := 1

    n++

    }

    fmt.Println(n)

    }
    ```

    0 потому что мы n заново объявили внутри условного оператора и значит это **ДРУГАЯ** n

    1. Что выведет данная программа и почему?

    ```golang
    func someAction(v []int8, b int8) {

    v[0] = 100

    v = append(v, b)

    }

    func main() {

    var a = []int8{1, 2, 3, 4, 5}

    someAction(a, 6)

    fmt.Println(a)

    }
    ```

    Та же история что и в задаче про передачу указателя. Слайсы - обёртка на указатель в памяти который ведёт на какой-то массив. Поэтому изменения в `v[0]` коснутся и слайса снаружи, а вот добавление нового объекта - нет, даже если память не была выделена но "заголовок" слайса не поменялся и во внешнем по-прежнему якобы 5 элементов.

1. - [x] Что выведет данная программа и почему?

    ```go
    func main() {

    slice := []string{ "a" , "a" }

    func (slice []string) {

    slice = append(slice, "a" )

    slice[0] = "b"

    slice[1] = "b"

    fmt.Print(slice)

    }(slice)

    fmt.Print(slice)

    }
    ```

    Два разных слайса `[b b a]` и `[a a]` т.к. произошло расширение вместимости (2->4) и старые данные были скопированы